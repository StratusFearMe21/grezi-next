@startuml
'https://plantuml.com/class-diagram

package grezi_parser {
    +struct GrzRoot {
        - viewboxes: HashMap<u64, Viewbox>
        - objects: HashMap<u64, Object>
        - slides: IndexMap<u64, Slide>
    }

    note left of GrzRoot::slides {
        IndexMap is like HashMap but with order
        retained and faster iteration
    }

    package parse {
        package cursor {
            interface IsNot {
                + is_not(&self) -> bool;
            }

            note top of IsNot {
                This trait is for making the result
                of `check_for_error` generic, so it
                can skip doing that when the result is
                already false or null (None in Rust's case)
            }

            +struct GrzCursor<'a> {
                - tree_cursor: tree_sitter::TreeCursor<'a>
                - rope: &'a Rope
                - errors: Arc<ErrsWithSource>
                + new(tree: &'a Tree, rope: &'a Rope, errors: Arc<ErrsWithSource>): Self
                + from_node(node: Node<'a>, rope: &'a Rope, errors: Arc<ErrsWithSource>): Self
                + goto_first_child<'b>(&'b mut self): io::Result<Option<GrzCursorGuard<'a, 'b>>>
                + goto_first_child_raw<'b>(&'b mut self): io::Result<Option<GrzCursorGuard<'a, 'b>>>
                + first_child_exists(&self): bool
                + first_child_raw_exists(&self): bool
                + goto_next_sibling(&mut self): io::Result<bool>
                + goto_next_sibling_raw(&mut self): io::Result<bool>
                + field_id(&self): Option<NonZeroU16>
                + node(&self): Node<'a>
                + id(&mut self, diff_size: usize): io::Result<u64>
                + char_range(&self): io::Result<CharRange>
                + rope_slice(&self): io::Result<RopeSlice<'a>>
                + node_hash(&self): io::Result<u64>
                + node_to_string_literal: io::Result<
                - check_for_error<T: IsNot + Debug>(&self, result: T): io::Result<T>
                - goto_first_impl(&mut self): io::Result<bool>
                - goto_next_impl(&mut self): io::Result<bool>
            }

            +struct GrzCursorGuard<'a, 'b> {
                - hostage_cursor: &'b mut GrzCursor<'a>
                - new_cursor: GrzCursor<'a>
                + parent_source(&self): io::Result<RopeSlice<'a>>
            }

            note left of GrzCursorGuard::parent_source {
                grabs the source code of the entire parent node that
                this cursor guard is protecting. This is useful for
                allowing the SpanTrace to contain more of the parser's
                state, as opposed to just the source of the first child
                of the parent node
            }

            GrzCursorGuard *-> GrzCursor

            note top of GrzCursorGuard {
                This struct is returned from GrzCursor::goto_first_child
                and GrzCursor::goto_first_child_raw and it exists for the
                purpose of preventing the user from advancing the parent
                cursor while traversing it's child, and allowing the function
                signatures of various types' parse functions to declare whether
                they're parsing nodes in the parent node the cursor is already in
                or if they're parsing child nodes of the node that the cursor is
                currently under
            }
        }

        package error {
            +struct IoError {
                +Arc<io::Error>
            }

            +enum ParseError {
                IoError(IoError),
                Syntax(super::CharRange, &'static str),
                Missing(super::CharRange, &'static str),
                NotFound(super::CharRange, &'static str),
                BadNode(super::CharRange, NodeKind, &'static str),
            }

            +struct ErrsWithSource {
                - errors: boxcar::Vec<(ParseError, SpanTrace)>
                - source_code: OnceLock<Arc<str>>
                + append_error(&self, error: ParseError, source: &Rope): void
                + is_empty(&self): bool
            }

            ParseError *-> ErrsWithSource
            IoError *--> ErrsWithSource

            note top of ErrsWithSource {
                This struct links errors to a version of our source code
                which is readable by our error reporting library (miette).

                Since turning a Rope into an Arc<str> (A reference counted
                immutable String) is expensive, we put it behind a OnceLock
                so it can only be initialized once, and it can be initialized
                without a mutable reference to an ErrsWithSource instance.

                We also store our errors inside a verison of the Vec type provided
                by the boxcar library which allows appending to it without a
                mutable reference to itself.

                Our errors also have an associated SpanTrace which is captured at the
                point in the code where the error is generated, thanks to the `append_error`
                function. The SpanTrace allows us to have a look at the state of the parser
                at the time the error was generated, which makes debugging much easier
            }

            note top of IoError {
                This allows fatal errors in the parser
                to be displayed more pretty in the error
                output, since we can customize how the Error
                and Display interfaces are implemented for
                this type
            }
        }

        +struct GrzFile {
            - parser: tree_sitter::Parser
            - incremental_state: Option<IncrementalState>
            + tree: Option<tree_sitter::Tree>
            + source: Rope
            + slideshow: GrzRoot
        }

        note left of GrzFile::source {
            Rope is like String but with faster editing
            and with the ability to be edited via Language
            Server TextEdits
        }

        note left of GrzFile::parser {
            We do not write the paresr, that's
            written for us by the `tree_sitter` library.
            What this package does is technically lexing
            the syntax tree we get from `tree_sitter`. Writing
            our own parser is pointless since `tree_sitter`
            gives you a bunch of really useful stuff for free,
            such as quickly querying the syntax tree, syntax
            highlighting in many editors, incremental parsing
            and more.
        }
    }

    package viewbox {
        +struct ViewboxRef {
            + vb_name: VbIdentifier
            + subbox: usize
            + parse(mut cursor: GrzCursorGuard, source: &Rope, errors: Arc<ErrsWithSource>): io::Result<()>
        }

        +struct Viewbox {
            + name: u64
            + split_on: ViewboxRef
            + inner: ViewboxInner
            + present: bool
            + parse(mut cursor: GrzCursorGuard, source: &Rope, errors: Arc<ErrsWithSource>): io::Result<()>
        }

        +struct ViewboxInner {
            + direction: Direction,
            + constraints: Vec<Constraint>
            + parse(mut cursor: GrzCursorGuard, source: &Rope, errors: Arc<ErrsWithSource>): io::Result<()>
        }

        +enum Direction {
            Horizontal, Vertical
        }

        +enum Constraint {
            Min(u16),
            Max(u16),
            Length(u16),
            Percentage(u16),
            Ratio(u32, u32),
            Fill(u16),
            + parse(mut cursor: GrzCursorGuard, source: &Rope, errors: Arc<ErrsWithSource>): io::Result<()>
        }

        +enum VbIdentifier {
            Named(u64),
            Size,
            Inherit,
            + parse(mut cursor: GrzCursorGuard, source: &Rope, errors: Arc<ErrsWithSource>): io::Result<()>
        }

        Direction *--> ViewboxInner
        Constraint *--> ViewboxInner
        ViewboxInner *--> Viewbox
        VbIdentifier *-> ViewboxRef
        ViewboxRef *--> Viewbox

        note left of Viewbox::present {
            Used to remove viewboxes that
            are no longer in the syntax tree
        }
    }

    package slide {
        +struct Slide {
            + objects: Option<Vec<SlideObj>>
            + present: bool
            + parse(mut cursor: GrzCursorGuard, source: &Rope, errors: Arc<ErrsWithSource>): io::Result<()>
        }

        +struct SlideObj {
            + name: u64
            + viewbox: SlideVb
            + vb_from: Option<ViewboxRef>
            + positions: ObjPositions
        }

        +struct ObjPositions {
            + from_alignment: Option<Align2>
            + to_alignment: Option<Align2>
            + exiting: bool
        }

        +enum SlideVb {
            Viewbox(ViewboxRef),
            InnerVb(split_on),
            Implicit
        }
    }

    package object {
        +struct Object {
            + name: u64
            + parameters: ObjInner
            + present: bool
        }

        +enum ObjInner {
            + parse(mut cursor: GrzCursorGuard, source: &Rope, errors: Arc<ErrsWithSource>): io::Result<()>
        }

        +struct Text {
            + job: TextJob
            + line_height: Option<f32>
            + align: Align
        }

        +struct Image {
            + uri: String
            + scale: Option<emath::Vec2>
            + tint: ecolor::HexColor
        }

        +struct Rect {
            color: ecolor::HexColor
            height: f32
        }

        Object <-* ObjInner
        ObjInner <|-- Text
        ObjInner <|-- Image
        ObjInner <|-- Rect

        note top of ObjInner {
            ObjInner is a algebraic Rust enum,
            and the classes extending it
            are variants of this enum
        }
    }

    slide.Slide *-> GrzRoot
    viewbox.Viewbox *--> GrzRoot
    viewbox.ViewboxRef *-> slide.SlideObj
    viewbox.ViewboxRef *-> slide.SlideVb


    note top of parse {
        This module is behind the "parse"
        feature flag, and disables parsing
        of the model from a GRZ file when
        the feature flag is disabled. The
        model can still be deserialized from
        a binary format however.

        Every parse function you see on a struct
        in the grezi_parser package is implmented
        in the parse package
    }
}

note top of grezi_parser {
    Most structs in this package have all their
    fields public. This is because most of these
    structs are simply output from the parser.

    There will also be several other packages in this app,
    `grezi_egui`, `grezi_native`, and `grezi_remote`. I will
    design these packages once the `grezi_parser` package is
    finalized and implemented
}

@enduml